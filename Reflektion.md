# Reflektioner - Inledning

### Här nedan följer mina tankar och reflektioner kring min modul samt kapitel 2 och 3 i boken Clean Code.
<br>

| Namn / Typ | Reflektion och regler Clean Code, kap 2 | 
| ----------- | ----------- | 
| SpotPriceApi - Klass - [spotPriceApi.js](./energy-price-module/src/spotPriceApi.js) | Class Names - Ett klassnamn ska vara ett substantiv och ska reflekta vad klassen har för uppgift. Just den här klassen har jag ändrat namn på flertalet gånger eftersom jag hade svårt i text förklara vad den är och halkade ofta in i namn som beskriver vad den gör (t.ex. fetchDayAheadData). Jag är fortfarande inte nöjd med namnvalet för vet användaren vad ett spotpris är? Och går det med hjälp av namnet att förstå att att den faktiska requesten/responsen sker här?
| getTomorrowsElectricityData - Metod - [spotPriceApi.js](./energy-price-module/src/spotPriceApi.js) | Noise - Då boken lyfter vikten av att undvika brus och tar "data" som ett exempel på detta så funderade jag länge på vad jag hade kunnat ersätta data med i mitt fall? Då metodens uppgift är att hämta information via NordPools api så känns ändå data som ett "brus" jag kan argumentera för.
| calculateWattToKilowatt - Variabel - [index.js](./energy-price-module/src/index.js) | Pick One Word per Concept - Jag har försökt att vara så konsekvent som möjligt vid namngivning, dvs de metoder som hämtar någonting börjar sina namn med "get" och de metoder som räknar ut någonting börjar med "calculate" osv. Jag är i överlag nöjd med detta och tycker att jag följt konceptet tillfredställande.
| getHourlyPricesForOneBiddingZone - metod, hourlyPricesForBiddingZones - variabel, hourlyPricesForZone - variabel, dayAheadPricesAndZones - variabel - [spotPriceApi.js](./energy-price-module/src/spotPriceApi.js) | Make Meaningsful Distinction / Avoid Disinformation - Här vill jag lyfta fyra exempel bara för att vara så tydlig som möjligt. Mycket i min modul går ut på att göra samma sak, dvs att filtrera ut priser och zoner. Ett av de största bekymren jag då har haft i min modul är att på ett bra sätt skilja på alla de metoder och variabler som gör just detta och jag tycker inte att jag har lyckats skapa en tillräcklig tydlig distinktion mellan dom. Det blir lite "kaka-på-kaka" känsla. Sökvänligheten försämras också rejält när namnen inte får en tydlig skillnad.
| sortHoursPerHighestPrice - metod - [index.js](./energy-price-module/src/index.js) | Use Intention-Revealing Names - Det är viktigt att metoden / variabeln talar om vad den faktiskt gör, att den programmerare som ska använda sig av din kod förstår vad den försöker att säga. Trots att jag många gånger gick vilse i namngivningsträsket när det kom till metoder / variabler som nästan gör samma sak så tycker jag ändå att jag i många fall lyckats förklara vad de gör, så även denna. 

<br>
<br>

| Metod | Antal rader | Reflektion och regler Clean Code, kap 3 | 
| ----------- | ----------- | ----------- | 
| getHourlyPricesForOneBiddingZone - [index.js](./energy-price-module/src/index.js)  | 18 | Small! - En metod ska vara liten och ännu mindre än så. Här har istället metoden fått breda ut sig över nästan 20 rader och blivit svår att få grepp över, även för mig. En naturlig åtgärd hade varit att plocka ner metoden i mindre metoder, men då metoden hanterar responsen från Apiet som bestod av 3600 rader kod av nästlade arrayer och objekt tvingade den även in mig i härvan som uppstår av att använda nästlade loopar. Boken lyfter faktiskt att en metod inte ska vara tillräckligt stor för att kunna hålla nästlade strukturer men jag vet inte hur jag hade kunnat bryta ner metoden i mindre delar, i alla fall inte utan handledning.
| calculatePropaneKilowattPrice - [index.js](./energy-price-module/src/index.js) | 10 | Do one thing - En metod ska egentligen bara göra en sak (eller flertalet så länge de ligger på samma abstraktionsnivå) och jag är kluven om denna metod räknas som att den gör en sak, eller om den gör "för mycket"? Den gör flertalet anrop till andra metoder för att själv slippa ta hand om "hela problemet" men jag har svårt att avgöra om allt det den gör faktiskt kan klassas som att vara på samma abstraktionsnivå?
| getHoursWhenPropaneIsCheaper - [index.js](./energy-price-module/src/index.js) | 21 | Do Not Repeat Yourself! - Är ett tankesätt som varenda programmerare får lära sig tidigt men trots detta så fortsätter vi att gå i fällan. Denna metod är nästintill en kopia av metoder getHourlyPricesForOneBiddingZone på det sättet att det är en skillnad i if-satsen och ytterligare en variabel läggs till. En lösning hade varit att " slå två flugor i en smäll", dvs när metoden getHourlyPricesForOneBiddingZone bryts ner i mindre metoder så blir det enkelt att även plocka isär den här metoden till att faktiskt bara göra en sak, dvs den saken som skiljer den från getHourlyPricesForOneBiddingZone.
| calculateConsumtionCostPerDayForProduct - [index.js](./energy-price-module/src/index.js) | 7 | Arguments / Triads - Den här metoden är inte särskilt lång men då boken lyfter vikten av att ha inga eller få argument men i och med att den här metoden gör precis tvärtom med sina 3 parametrar så vill jag ändå reflektera kring den. Just i det här fallet så har jag svårt att se hur jag hade kunnat undvika tre argument då beräkningen som utförs inuti metoden baseras på tre värden som kommer från en användare. Även om det i praktiken är möjligt att bryta ner metoden i mindre delar så måste den här beräkningen utföras någonstans, och där behövs då även användarens inmatningar.
| extractElectricityPricesAndZones - [spotPriceApi.js](./energy-price-module/src/spotPriceApi.js) | 18 | Side Effects - Den här metoden extraherar priserna för de fyra elområderna ur responset. Den omvandlar också värdet till svenska ören genom metodanropet "const pennies = this.#roundDecimalsFoundInNumber(value)" där ett otillgängligt dagspris sätter värdet till 0.00. Faller detta inom ramen för sidoeffekter? I boken så visar exemplet hur ett if statement vid true, kallar på Session.initialize() och pekar på att detta är en typisk sidoeffekt. Kan man tänka skillnaden som att min metod bara returnerar ett värde och dess effekt är därför känd, medan Session.initialize() bär iväg till andra delar av systemet och skapar händelsekedjor som min metod "extractElectricityPricesAndZones" inte känner till? Och därav klassas det som en sidoeffekt? (I så fall så handlar snarare metodens huvudproblem om att den gör saker som namnet inte skvallrar om, dvs det vi läste om under Avoid Disinformation och Do One Thing) 

<br>

## Slutsats / Reflektion
Min första reaktion när jag började bläddra i boken, och framförallt kapitel 2, var att: "Hur svårt kan det vara att komma fram till bra namn? Det är väl bara att beskriva vad metoden/variabeln gör?" Såhär i efterhand så inser jag ju att jag troligtvis inte hade kunnat ha mer fel? (Att det finns åtskilliga artiklar och böcker om ämnet borde ha gett mig en hint om hur komplext detta ämne faktiskt är) För det som faktiskt skedde när jag hade läst kapitlet och börjat fundera över namnvalen i min egen kod så insåg jag tämligen omgående att beskriva vad någonting gör utan att för den delen lägga till "noise" eller ord som kan vara missvisande för en annan användare (eller till och med för mig själv), det var ingenting som visade sig vara enkelt. Ännu svårare var det när jag insåg att vissa metoder faktiskt inte bara gör en sak, utan kanske flera. Och hur jag än försökte namnge den så blev namnet vilseledande, om jag nu inte ville ange den som att "getElecitricyDataForAllZonesAndTheConvertTheValueToSwedishPenniesAndThen..." osv osv. vilket hade varit ohållbart ur alla möjliga perspektiv.
Det positiva med att se över namnen, förutom att de blev tydligare, var att det faktiskt var mycket lättare att hitta de här metoderna som jag först tyckte gjorde en sak men när jag såg över namnet insåg att den här gör faktiskt flera saker, och jag kunde på så sätt bryta upp metoden i flera delar. Ett exempel är metoden calculatePropaneKilowattPrice som först tog hand om alla beräkningar men numera fördelar ut uppgifter till andra metoder, till exempel till metoden this.#dividePropanePriceWithKilogram. Tydligt och bra!

 Det är oerhört lätt att bli hemmablind, att tro att koden som man själv suttit många timmar med är tillräckligt tydlig och förklarar sig själv även för andra. Jag tycker överlag att jag har bra namngivning på främst mina metoder och ett sätt jag kontrollerade detta var att fråga min sambo, som inte har några programmeringskunskaper, om hon utifrån namnet kunde lista ut vad metoden gör. Blev svaret ja så visste jag att jag var någonting på spåren.

Under stycket "One Level of Abstraction Per Function" så lyfter boken att ifall man mixar olika abstraktionsnivåer så leder detta bara till förvirring och desinformation. Jag hade initialt stora problem med responsen från Apiet då det bestod av nästlade arrayer vilket tvingade in mig att själv använda nästlade loopar för att extrahera den information jag behövde. Detta bidrog till att metoderna växte och fick alldeles för stort ansvar och skapade olika abstraktionsnivåer. Jag försökte bryta isär min spagettikod av nästlade loopar men kände inte att jag lyckades tillräckligt väl för att känna att det gjorde skillnad. Snarare skapade det förvirring på andra sätt. Däremot tycker jag att jag tagit åt mig regeln "The Stepdown rule" på ett godtagbart sätt, jag tycker att min kod är enkelt att följa och kan i de allra flesta fall enkelt läsas från toppen till botten.

Jag tycker även att jag har kapslat in modulen på ett bra sätt, de metoder som ska vara tillgängliga för andra programmerare att använda är publika medan de metoder som jag inte vill ska vara synliga är satta till privata. Dels så minimerar det risken att metoder havererar på grund av felaktiga argument och dels så är det enklare för en annan programmerare att använda sig av modulen när enbart de metoderna som ska användas är de enda som är synliga. 

Jag är i det stora hela nöjd med min insats, mycket hade såklart kunnat göras bättre men mycket blev ändå bra, och det är också viktigt att ta med sig.
